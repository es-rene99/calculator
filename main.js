/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (() => {

eval("/* eslint-disable spaced-comment */\nconst calculator = (() => {\n  function replaceAnsOnTerm(term, previousOperationResult) {\n    return term.reduce((total, num) => {\n      if (num === 'Ans') {\n        const replacedAnsNum = previousOperationResult;\n        return total * replacedAnsNum;\n      }\n      return total + num;\n    });\n  }\n\n  const operate = (firstTerm, secondTerm, operator, previousOperationResult) => {\n    const firstTermClean = +replaceAnsOnTerm(firstTerm, previousOperationResult);\n    const secondTermClean = +replaceAnsOnTerm(secondTerm, previousOperationResult);\n    switch (operator) {\n      case '+':\n        return firstTermClean + secondTermClean;\n      case '-':\n        return firstTermClean - secondTermClean;\n      case '*':\n        return firstTermClean * secondTermClean;\n      case '/':\n        return firstTermClean / secondTermClean;\n      default:\n        return 'error, not valid operator';\n    }\n  };\n  return {\n    operate,\n  };\n})();\n\nconst uiDOMManipulation = (() => {\n  const keysDataSet = {\n    numberKeysDataSet: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, '.', '?'],\n    operatorKeysDataSet: ['DEL', 'AC', '+', '-', '*', '/', 'ANS', '='],\n    specialKeyDataSet: ['DEL', 'AC', 'ANS', '='],\n  };\n  //#region\n  const calculatorKeyClasses = {\n    calculatorKey: 'calculator__key',\n    calculatorNumberKey: 'calculator__number-key',\n    calculatorOperatorKey: 'calculator__operator-key',\n    calculatorSpecialKey: 'calculator__special-key',\n  };\n\n  let display = [];\n  function getDisplayValue() {\n    return (display.length !== 0) ? display.join('') : display;\n  }\n  const calculatorScreen = document.querySelector('.calculator__screen');\n  let operationResult;\n  let previousTerm;\n  let previousOperationResult = 0;\n  let previousActionWasAnOperation = false;\n  let storedOperator;\n  let consecutiveStoredOperator;\n  let isActionOnDisplayAlreadyMade;\n  let isReadyForOperation;\n\n  const possibleCalculatorActions = {\n    cleanDisplayIfPreviousActionWasOperation() {\n      if (previousActionWasAnOperation && !isReadyForOperation) {\n        display = [];\n        operationResult = [];\n        previousActionWasAnOperation = false;\n      }\n    },\n    isSpecialKeyActions(keyValue, specificClass) {\n      if (specificClass === calculatorKeyClasses.calculatorSpecialKey\n        && !isActionOnDisplayAlreadyMade) {\n        switch (keyValue) {\n          case 'AC':\n            storedOperator = undefined;\n            display = [];\n            operationResult = [];\n            break;\n          case 'DEL':\n            if (display.length > 0) {\n              display.pop();\n            } else {\n              // TODO add display = \"I'm empty inside :(\";\n            }\n            break;\n\n          case 'ANS':\n            // TODO if ans is undefined add a \"hey but I still haven't even done an operation!\"\n            display.push('Ans');\n            break;\n\n          case '=':\n            isReadyForOperation = true;\n            break;\n\n          default:\n            break;\n        }\n\n        isActionOnDisplayAlreadyMade = true;\n      }\n    },\n    isNumberKeyActions(keyValue, specificClass) {\n      if (specificClass === calculatorKeyClasses.calculatorNumberKey && !isActionOnDisplayAlreadyMade) {\n        display.push(keyValue);\n        isActionOnDisplayAlreadyMade = true;\n      }\n    },\n    operationsIfValidToDoOperations(keyValue) {\n      if (storedOperator !== undefined && isReadyForOperation && !previousActionWasAnOperation) {\n        operationResult = calculator.operate(\n          previousTerm,\n          display,\n          storedOperator,\n          previousOperationResult,\n        );\n        display = [operationResult];\n        previousOperationResult = operationResult;\n        previousActionWasAnOperation = true;\n\n        if (keyValue === '=') {\n          storedOperator = undefined;\n          previousTerm = undefined;\n        } else {\n          previousTerm = [operationResult];\n        }\n        if (consecutiveStoredOperator !== undefined && storedOperator !== undefined) {\n          storedOperator = consecutiveStoredOperator;\n        }\n        isReadyForOperation = false;\n        isActionOnDisplayAlreadyMade = true;\n      }\n    },\n    saveOperatorValue(keyValue, specificClass) {\n      if (!isActionOnDisplayAlreadyMade\n        && specificClass === calculatorKeyClasses.calculatorOperatorKey) {\n        if (storedOperator !== undefined) {\n          consecutiveStoredOperator = keyValue;\n        } else {\n          storedOperator = keyValue;\n        }\n        if (previousTerm !== undefined) {\n          isReadyForOperation = true;\n        } else {\n          previousTerm = display;\n          display = [];\n        }\n        isActionOnDisplayAlreadyMade = true;\n      }\n    },\n  };\n\n  function updateScreen() {\n    calculatorScreen.textContent = getDisplayValue();\n  }\n\n  const determineActionOnDisplay = (keyValue, specificClass) => {\n    isActionOnDisplayAlreadyMade = false;\n    possibleCalculatorActions.saveOperatorValue(keyValue, specificClass);\n    possibleCalculatorActions.cleanDisplayIfPreviousActionWasOperation();\n    possibleCalculatorActions.isSpecialKeyActions(keyValue, specificClass);\n    possibleCalculatorActions.isNumberKeyActions(keyValue, specificClass);\n    possibleCalculatorActions.operationsIfValidToDoOperations(keyValue);\n    updateScreen();\n  };\n  //#endregion\n\n  const createCalculatorKeys = () => {\n    function typeKey(e) {\n      let keyValue;\n      let specificClass;\n      if (e.key !== undefined) {\n        console.log(e.key);\n        // TODO need to do more tests for backspace\n        let keyToEvaluate = e.key;\n        if (e.key === 'Backspace') {\n          keyToEvaluate = 'DEL';\n        }\n        if (keysDataSet.numberKeysDataSet.some((number) => keyToEvaluate === number.toString())) {\n          specificClass = calculatorKeyClasses.calculatorNumberKey;\n        } else if (keysDataSet.operatorKeysDataSet.some((operator) => keyToEvaluate === operator)) {\n          specificClass = calculatorKeyClasses.calculatorOperatorKey;\n          if (keysDataSet.specialKeyDataSet.some((operator) => keyToEvaluate === operator)) {\n            specificClass = calculatorKeyClasses.calculatorSpecialKey;\n          }\n        }\n        if (specificClass !== undefined) {\n          keyValue = keyToEvaluate;\n        } else {\n          return;\n        }\n      } else {\n        keyValue = e.srcElement.dataset.keyValue;\n        specificClass = e.srcElement.classList[e.srcElement.classList.length - 1];\n      }\n      determineActionOnDisplay(keyValue, specificClass);\n    }\n\n    function setSpecialCharClass(newElement, newElementDataSet, i) {\n      if (keysDataSet.specialKeyDataSet.some((textValue) => textValue === newElementDataSet[i])) {\n        newElement.classList.add('calculator__special-key');\n      }\n    }\n    function createKeyLayout(targetElementClass, newElementClass, newElementDataSet) {\n      const targetElement = document.querySelector(targetElementClass);\n      for (let i = 0; i < newElementDataSet.length; i++) {\n        const newElementValue = newElementDataSet[i];\n        const newElement = document.createElement('div');\n        newElement.classList.add(...newElementClass);\n        newElement.setAttribute('data-key-value', newElementDataSet[i]);\n        if (newElementClass[1] === calculatorKeyClasses.calculatorOperatorKey) {\n          setSpecialCharClass(newElement, newElementDataSet, i);\n        }\n        newElement.textContent = newElementValue;\n        targetElement.appendChild(newElement);\n        newElement.addEventListener('click', typeKey);\n      }\n    }\n    createKeyLayout('.calculator__number-keys', [calculatorKeyClasses.calculatorKey, calculatorKeyClasses.calculatorNumberKey], keysDataSet.numberKeysDataSet);\n    createKeyLayout('.calculator__operator-keys', [calculatorKeyClasses.calculatorKey, calculatorKeyClasses.calculatorOperatorKey], keysDataSet.operatorKeysDataSet);\n    // * Keyboard support\n    window.addEventListener('keydown', typeKey);\n  };\n\n  return {\n    createCalculatorKeys,\n  };\n})();\n\nconst main = (() => {\n  const init = () => {\n    uiDOMManipulation.createCalculatorKeys();\n  };\n  return {\n    init,\n  };\n})();\n\nmain.init();\n\n\n//# sourceURL=webpack://calculator/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"]();
/******/ 	
/******/ })()
;